package merge

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/spf13/cobra"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	goimport "golang.org/x/tools/imports"
	"os"
	"slices"
	"strings"
)

func merge(cmd *cobra.Command, files []string, output string) error {
	fset := token.NewFileSet()
	var (
		pkg     string
		imports bytes.Buffer
		decls   bytes.Buffer
	)
	for _, file := range files {
		f, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
		if err != nil {
			return err
		}
		if pkg == "" {
			pkg = f.Name.String()
		}
		if pkg != f.Name.String() {
			return errors.New("conflicting packages are not equal")
		}
		for _, importSpec := range f.Imports {
			if err = printer.Fprint(&imports, fset, importSpec); err != nil {
				return err
			}
			imports.WriteByte('\n')
		}
		for _, decl := range f.Decls {
			if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.IMPORT {
				continue
			}
			if err = printer.Fprint(&decls, fset, decl); err != nil {
				return err
			}
			decls.WriteString("\n\n")
		}
	}
	var buf bytes.Buffer
	commands := []string{cmd.Name()}
	for cmd = cmd.Parent(); cmd != nil; cmd = cmd.Parent() {
		commands = append(commands, cmd.Name())
	}
	slices.Reverse(commands)
	fmt.Fprintf(&buf, "// Code generated by %q, DO NOT EDIT.\n\n", strings.Join(commands, " "))
	fmt.Fprintf(&buf, "package %s\n\n", pkg)
	fmt.Fprintf(&buf, "import (\n%s\n)\n\n", imports.String())
	fmt.Fprintf(&buf, "%s", decls.String())
	code, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	if err = os.WriteFile(output, code, 0644); err != nil {
		return err
	}
	code, err = goimport.Process(output, nil, nil)
	if err != nil {
		return err
	}
	if err = os.WriteFile(output, code, 0644); err != nil {
		return err
	}
	return nil
}
